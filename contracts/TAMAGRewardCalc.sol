pragma solidity ^0.6.12;
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/math/SafeMath.sol";
import "./ITAMAG.sol";
import "@openzeppelin/contracts/utils/EnumerableSet.sol";


// each tamag has a virtual amount to represent how much yield it can get.
// base yield = energy + metabolism
// bonus of 30% applies for OG1
// bonus of 15% applies for OG2

// NFT items
// distribute every 4 hours, tamag must have at least 2h of that window in staking to be eligible
// force addresses to enroll
// get all tamag present in staker contract
// calculate cheerfulness, random number generated by blockhash-1, 

// OG1 - (20-30)% chance for common + (3-6)% chance for rare, (1-1.5)% chance for ultra rare
// OG2 - (15-25)% chance for common + (1.5-3)% chance for rare, (0.5-1.0)% chance for ultra rare
// others - (5-10)% chance for common + (0.5-1.5)% chance for rare, (0.25-0.75)% chance for ultra rare
// ranges are based on cheerfulness



contract TAMAGRewardCalc is Ownable{
    using SafeMath for uint256;
    using EnumerableSet for EnumerableSet.UintSet;

    EnumerableSet.UintSet og1;
    EnumerableSet.UintSet og2;

    ITAMAG tamag;

    uint256 public OG1_BONUS = 130;
    uint256 public OG2_BONUS = 115;

    constructor(address _tamag) public{
        uint8[30] memory og1s = [1,  2,  3,  4,  5,  6,  7,  8,  9,
            10, 11, 12, 13, 14, 15, 16, 17, 18,
            19, 20, 21, 22, 23, 26, 28, 29, 31,
            41, 42, 46];
        uint8[25] memory og2s = [
            24, 25, 27, 30, 32, 33, 34, 35,
            36, 37, 38, 39, 40, 43, 44, 45,
            47, 48, 49, 50, 51, 52, 53, 54,
            55
        ];
        for (uint i = 0; i < 30; i++){
            og1.add(og1s[i]);
        }
        for (uint i = 0; i < 25; i++){
            og2.add(og2s[i]);
        }
       
        tamag = ITAMAG(_tamag);
    }

    function adOG1(uint tamagId) public onlyOwner {
        og1.add(tamagId);
    }
    function removeOG1(uint tamagId) public onlyOwner {
        og1.remove(tamagId);
    }
    function addOG2(uint tamagId) public onlyOwner {
        og2.add(tamagId);
    }
    function removeOG2(uint tamagId) public onlyOwner {
        og2.remove(tamagId);
    }

    function close() public onlyOwner { 
        address payable p = payable(owner());
        selfdestruct(p); 
    }
    function getTamagTrait(uint256 tamagId) public view returns (uint256, uint256, uint256, uint256) {
        uint256 trait = tamag.getTrait(tamagId);
        uint256 cheerfulness = getCheerfulness(trait);
        uint256 energy = getEnergy(trait);
        uint256 metabolism = getMetabolism(trait);
        return (trait, cheerfulness, energy, metabolism);
    }
    // make sure this amt roughly on same magnitude with 1e18
    function getVirtualAmt(uint256 tamagId) public view returns (uint256) {
        uint256 trait = tamag.getTrait(tamagId);
        // uint256 cheerfulness = getCheerfulness(trait);
        uint256 energy = getEnergy(trait);
        uint256 metabolism = getMetabolism(trait);
        // values obtained are out of 0-31 inclusive
        
        uint256 result = energy.add(metabolism).mul(1e18); // range of 0-64 1E18
        if (og1.contains(tamagId)){
            result = result.mul(OG1_BONUS).div(100);
        }else if (og2.contains(tamagId)){
            result = result.mul(OG2_BONUS).div(100);
        }
        return result;
    }

    function _sliceNumber(uint256 _n, uint8 _nbits, uint8 _offset) private pure returns (uint8) {
        // mask is made by shifting left an offset number of times
        uint256 mask = uint256((2**uint256(_nbits)) - 1) << _offset;
        // AND n with mask, and trim to max of _nbits bits
        return uint8((_n & mask) >> _offset);
    }

    function getCheerfulness(uint256 trait) public view returns (uint256) {
        return _sliceNumber(trait, 5, 0);
    }
    function getEnergy(uint256 trait) public view returns (uint256) {
        return _sliceNumber(trait, 5, 5);
    }
    function getMetabolism(uint256 trait) public view returns (uint256) {
        return _sliceNumber(trait, 5, 10);
    }
    function setOG1_BONUS(uint256 bonus) public onlyOwner {
        OG1_BONUS = bonus; 
    }
    function setOG2_BONUS(uint256 bonus) public onlyOwner {
        OG2_BONUS = bonus; 
    }
}